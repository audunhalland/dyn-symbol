//!
//! Dynamic, plugin-based [Symbol](https://en.wikipedia.org/wiki/Symbol_(programming)) abstraction.
//!
//! A [Symbol] can be used as an _identifier_ in place of a primitive [String].
//! There could be multiple reasons to do so:
//!
//! 1. Mixing of different domains in the same runtime code
//! 2. Handling of naming collisions in multiple namespaces
//! 3. Avoiding memory allocations for statically known namespaces
//! 4. Mix of static and dynamic allocation
//! 5. Associating metadata to the symbols themselves
//!
//! There are probably more reasons _not_ to use symbols than to use them!
//!
//! # Example usages:
//! * Namespaced XML/HTML attributes (in HTML, some are static and some are dynamic. e.g. `data-` attributes)
//! * Large maps that can store "anything"
//! * Some way to abstract away string interners? (untested)
//!
//! A [Symbol] is just one type, that can represent all possible symbol values. It implements all traits to make it
//! usable as a key for maps.
//!
//! # Static symbols
//! Static symbols originate from a namespace where all possible values are statically known at compile time.
//! One instance of a static symbol requires no memory allocation.
//!
//! Creating a static namespace:
//!
//! ```
//! use dyn_symbol::*;
//!
//! struct StaticNS {
//!     symbols: &'static [(&'static str, &'static str)],
//! }
//!
//! impl dyn_symbol::namespace::Static for StaticNS {
//!     fn namespace_name(&self) -> &str {
//!         "static"
//!     }
//!
//!     fn symbol_name(&self, id: u32) -> &str {
//!         self.symbols[id as usize].0
//!     }
//! }
//!
//! const STATIC_NS: StaticNS = StaticNS {
//!     symbols: &[
//!         ("foo", "the first symbol!"),
//!         ("bar", "the second symbol!")
//!     ]
//! };
//! const STATIC_NS_REF: StaticRef = StaticRef(&STATIC_NS);
//!
//! const fn foo() -> Symbol { Symbol::new_static(&STATIC_NS_REF, 0) }
//! const fn bar() -> Symbol { Symbol::new_static(&STATIC_NS_REF, 1) }
//!
//! assert_eq!(foo(), foo());
//! assert_ne!(foo(), bar());
//! assert_eq!(format!("{:?}", foo()), "static::foo");
//!
//! // We can find the originating namespace later:
//! assert!(foo().namespace().downcast_ref::<StaticNS>().is_some());
//!
//! // To implement special metadata-extraction (or similar functionality) for a namespace:
//! fn get_symbol_description(symbol: &Symbol) -> Result<&'static str, &'static str> {
//!     if let Some(namespace) = symbol.namespace().downcast_ref::<StaticNS>() {
//!         let id = symbol.static_id().unwrap();
//!         Ok(namespace.symbols[id as usize].1)
//!     } else {
//!         Err("not from this namespace :(")
//!     }
//! }
//!
//! assert_eq!(get_symbol_description(&bar()).unwrap(), "the second symbol!");
//! ```
//!
//! For static symbols, the implementations of [Eq], [Ord] and [std::hash::Hash] et. al use only the namespace's [std::any::Any::type_id]
//! and the number [StaticSymbol::id].
//!
//! Typically, the boilerplate code for a static namespace will be generated by macros or `build.rs`.
//!
//! # Dynamic symbols
//! Sometimes the values that a symbol can take are not known upfront. In this case we have to resort to memory allocation.
//! Dynamic symbols implement a different namespace trait: [namespace::Dynamic]. The type that implements this trait also
//! functions as the symbol _instance_ itself:
//!
//! ```
//! use dyn_symbol::*;
//!
//! // This symbol is string-based:
//! struct DynamicNS(String);
//!
//! impl namespace::Dynamic for DynamicNS {
//!     fn namespace_name(&self) -> &str {
//!         "dynamic"
//!     }
//!
//!     fn symbol_name(&self) -> &str {
//!         &self.0
//!     }
//!
//!     fn dyn_clone(&self) -> Box<dyn namespace::Dynamic> {
//!         Box::new(DynamicNS(self.0.clone()))
//!     }
//!
//!     /// Note: calling code should already have verified that these are indeed the same types, using `type_id`.
//!     fn dyn_eq(&self, rhs: &dyn namespace::Dynamic) -> bool {
//!         self.0 == rhs.downcast_ref::<DynamicNS>().unwrap().0
//!     }
//!
//!     fn dyn_cmp(&self, rhs: &dyn namespace::Dynamic) -> std::cmp::Ordering {
//!         self.0.cmp(&rhs.downcast_ref::<DynamicNS>().unwrap().0)
//!     }
//!
//!     fn dyn_hash(&self, state: &mut dyn std::hash::Hasher) {
//!         // we are now in `dyn` land, so the [std::hash::Hash] trait cannot be used:
//!         state.write(self.0.as_bytes());
//!         state.write_u8(0xff)
//!     }
//! }
//!
//! let foo0 = Symbol::new_dynamic(Box::new(DynamicNS("foo".into())));
//! let foo1 = Symbol::new_dynamic(Box::new(DynamicNS("foo".into())));
//! let bar = Symbol::new_dynamic(Box::new(DynamicNS("bar".into())));
//!
//! assert_eq!(foo0, foo1);
//! assert_ne!(foo0, bar);
//! ```
//!
//! It is entirely up to the Dynamic implementation to consider what kind of symbols are considered equal.
//!
//! Dynamic symbols are supported as a companion to static symbols. If your application works mainly with dynamic symbols,
//! you should consider using a different keying mechanism, because of the overhead it incurs.
//!
//! # Type system
//! This crate makes use of [std::any::Any], and consideres namespace types with the same `type_id` to be the same namespace.
//! This could make code reuse a bit cumbersome. If a crate exports multiple namespaces, this can be solved by using const generics:
//!
//! ```
//! struct MyNamespace<const N: u8>;
//!
//! // impl<const N: u8> namespace::Static for MyNamespace<N> { ... }
//!
//! const NS_1: MyNamespace<1> = MyNamespace;
//! const NS_2: MyNamespace<2> = MyNamespace;
//! ```
//!
//! This will cause the two namespaces to have differing `type_id`s.
//!
//!

use std::cmp::Ordering;

///
/// A symbol, with support for mixed static/dynamic allocation.
///
pub enum Symbol {
    Static(&'static StaticRef, u32),
    Dyn(Box<dyn namespace::Dynamic>),
}

impl Symbol {
    ///
    /// Construct a new static symbol.
    ///
    pub const fn new_static(symbol: &'static StaticRef, id: u32) -> Self {
        Self::Static(symbol, id)
    }

    ///
    /// Construct a new dynamic symbol.
    ///
    pub fn new_dynamic(symbol: Box<dyn namespace::Dynamic>) -> Self {
        Self::Dyn(symbol)
    }

    ///
    /// Get a [std::any::Any] reference to the symbol's originating namespace.
    ///
    pub fn namespace(&self) -> &dyn std::any::Any {
        match self {
            Self::Static(ns, _) => ns.0.as_any(),
            Self::Dyn(this) => this.as_any(),
        }
    }

    ///
    /// Get the symbol's static id in case it's static, or [None] if it's not static.
    ///
    pub fn static_id(&self) -> Option<u32> {
        match self {
            Self::Static(_, id) => Some(*id),
            Self::Dyn(_) => None,
        }
    }
}

impl Clone for Symbol {
    fn clone(&self) -> Self {
        match self {
            Self::Static(static_symbol, id) => Self::Static(static_symbol, *id),
            Self::Dyn(instance) => Self::Dyn(instance.dyn_clone()),
        }
    }
}

impl std::fmt::Debug for Symbol {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Self::Static(ns, id) => {
                write!(f, "{}::{}", ns.0.namespace_name(), ns.0.symbol_name(*id))
            }
            Self::Dyn(instance) => {
                write!(
                    f,
                    "{}::{}",
                    instance.namespace_name(),
                    instance.symbol_name()
                )
            }
        }
    }
}

impl PartialEq for Symbol {
    fn eq(&self, rhs: &Symbol) -> bool {
        match (self, rhs) {
            (Self::Static(this_ns, this_id), Self::Static(rhs_ns, rhs_id)) => {
                *this_id == *rhs_id && this_ns.0.type_id() == rhs_ns.0.type_id()
            }
            (Self::Dyn(this), Self::Dyn(rhs)) => {
                this.type_id() == rhs.type_id() && this.dyn_eq(rhs.as_ref())
            }
            _ => false,
        }
    }
}

impl Eq for Symbol {}

impl Ord for Symbol {
    fn cmp(&self, rhs: &Symbol) -> Ordering {
        match (self, rhs) {
            (Self::Static(this_ns, this_id), Self::Static(rhs_ns, rhs_id)) => {
                let this_type_id = this_ns.0.type_id();
                let rhs_type_id = rhs_ns.0.type_id();

                if this_type_id == rhs_type_id {
                    this_id.cmp(&rhs_id)
                } else {
                    this_type_id.cmp(&rhs_type_id)
                }
            }
            (Self::Dyn(this), Self::Dyn(rhs)) => {
                let this_type_id = this.type_id();
                let rhs_type_id = rhs.type_id();

                if this_type_id == rhs_type_id {
                    this.dyn_cmp(rhs.as_ref())
                } else {
                    this_type_id.cmp(&rhs_type_id)
                }
            }
            (Self::Static(_, _), Self::Dyn(_)) => Ordering::Less,
            (Self::Dyn(_), Self::Static(_, _)) => Ordering::Greater,
        }
    }
}

impl PartialOrd for Symbol {
    fn partial_cmp(&self, other: &Symbol) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl std::hash::Hash for Symbol {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        match self {
            Self::Static(ns, id) => {
                ns.0.type_id().hash(state);
                state.write_u32(*id)
            }
            Self::Dyn(dynamic_sym) => {
                dynamic_sym.type_id().hash(state);
                dynamic_sym.dyn_hash(state)
            }
        }
    }
}

///
/// Indirection of a static namespace, to reduce the size of [Symbol].
///
pub struct StaticRef(pub &'static dyn namespace::Static);

pub mod namespace {
    use downcast_rs::*;

    pub trait Static: Send + Sync + Downcast {
        fn namespace_name(&self) -> &str;
        fn symbol_name(&self, id: u32) -> &str;
    }

    pub trait Dynamic: Send + Sync + Downcast {
        fn namespace_name(&self) -> &str;
        fn symbol_name(&self) -> &str;

        fn dyn_clone(&self) -> Box<dyn Dynamic>;
        fn dyn_eq(&self, rhs: &dyn Dynamic) -> bool;
        fn dyn_cmp(&self, rhs: &dyn Dynamic) -> std::cmp::Ordering;
        fn dyn_hash(&self, state: &mut dyn std::hash::Hasher);
    }

    impl_downcast!(Dynamic);
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::hash::{BuildHasher, Hash, Hasher};

    mod _static {
        use super::*;

        struct ClassN<const N: u8> {
            class_name: &'static str,
            names: &'static [&'static str],
        }

        impl<const N: u8> namespace::Static for ClassN<N> {
            fn namespace_name(&self) -> &str {
                self.class_name
            }

            fn symbol_name(&self, id: u32) -> &str {
                self.names[id as usize]
            }
        }

        const STATIC_NS_CLASS_A: ClassN<1> = ClassN {
            class_name: "A",
            names: &["0", "1"],
        };
        const STATIC_NS_CLASS_B: ClassN<2> = ClassN {
            class_name: "B",
            names: &["0"],
        };

        pub const STATIC_REF_A: StaticRef = StaticRef(&STATIC_NS_CLASS_A);
        pub const STATIC_REF_B: StaticRef = StaticRef(&STATIC_NS_CLASS_B);
    }

    mod dynamic {
        use super::*;

        pub struct TestDynamic<const N: u8>(pub String, &'static str);

        impl<const N: u8> namespace::Dynamic for TestDynamic<N> {
            fn namespace_name(&self) -> &str {
                self.1
            }

            fn symbol_name(&self) -> &str {
                &self.0
            }

            fn dyn_clone(&self) -> Box<dyn namespace::Dynamic> {
                Box::new(TestDynamic::<N>(self.0.clone(), self.1))
            }

            fn dyn_eq(&self, rhs: &dyn namespace::Dynamic) -> bool {
                self.0 == rhs.downcast_ref::<TestDynamic<N>>().unwrap().0
            }

            fn dyn_cmp(&self, rhs: &dyn namespace::Dynamic) -> std::cmp::Ordering {
                self.0.cmp(&rhs.downcast_ref::<TestDynamic<N>>().unwrap().0)
            }

            fn dyn_hash(&self, state: &mut dyn std::hash::Hasher) {
                state.write(self.0.as_bytes());
                state.write_u8(0xff)
            }
        }

        pub fn sym0(str: &str) -> Symbol {
            Symbol::new_dynamic(Box::new(TestDynamic::<0>(str.into(), "dyn0")))
        }

        pub fn sym1(str: &str) -> Symbol {
            Symbol::new_dynamic(Box::new(TestDynamic::<1>(str.into(), "dyn1")))
        }
    }

    const STATIC_A_0: Symbol = Symbol::new_static(&_static::STATIC_REF_A, 0);
    const STATIC_A_1: Symbol = Symbol::new_static(&_static::STATIC_REF_A, 1);
    const STATIC_B_0: Symbol = Symbol::new_static(&_static::STATIC_REF_B, 0);

    struct TestState {
        random_state: std::collections::hash_map::RandomState,
    }

    impl TestState {
        pub fn new() -> Self {
            Self {
                random_state: std::collections::hash_map::RandomState::new(),
            }
        }

        fn assert_hash_match(&self, a: &Symbol, b: &Symbol, should_equal: bool) {
            let mut hasher_a = self.random_state.build_hasher();
            let mut hasher_b = self.random_state.build_hasher();

            a.hash(&mut hasher_a);
            b.hash(&mut hasher_b);

            if should_equal {
                assert_eq!(hasher_a.finish(), hasher_b.finish())
            } else {
                assert_ne!(hasher_a.finish(), hasher_b.finish())
            }
        }

        fn assert_full_eq(&self, a: &Symbol, b: &Symbol) {
            assert_eq!(a, b);
            assert_eq!(a.cmp(b), Ordering::Equal);
            self.assert_hash_match(a, b, true)
        }

        fn assert_full_ne(&self, a: &Symbol, b: &Symbol) {
            assert_ne!(a, b);
            assert_ne!(a.cmp(b), Ordering::Equal);
            self.assert_hash_match(a, b, false)
        }
    }

    #[test]
    fn test_symbol_size_of() {
        assert_eq!(
            std::mem::size_of::<Symbol>(),
            3 * std::mem::size_of::<usize>()
        )
    }

    #[test]
    fn test_debug() {
        assert_eq!(format!("{:?}", STATIC_A_0), "A::0");
        assert_eq!(format!("{:?}", STATIC_A_1), "A::1");
        assert_eq!(format!("{:?}", STATIC_B_0), "B::0");

        assert_eq!(format!("{:?}", dynamic::sym0("foo")), "dyn0::foo");
        assert_eq!(format!("{:?}", dynamic::sym1("bar")), "dyn1::bar");
    }

    #[test]
    fn test_equality() {
        let test_state = TestState::new();

        test_state.assert_full_eq(&STATIC_A_0, &STATIC_A_0);
        test_state.assert_full_eq(&STATIC_A_1, &STATIC_A_1);
        test_state.assert_full_eq(&STATIC_B_0, &STATIC_B_0);

        test_state.assert_full_ne(&STATIC_A_0, &STATIC_A_1);
        test_state.assert_full_ne(&STATIC_A_1, &STATIC_B_0);

        test_state.assert_full_eq(&dynamic::sym0("foo"), &dynamic::sym0("foo"));
    }

    #[test]
    fn test_inequality() {
        let test_state = TestState::new();

        test_state.assert_full_ne(&STATIC_A_0, &STATIC_A_1);
        test_state.assert_full_ne(&STATIC_A_0, &STATIC_B_0);

        test_state.assert_full_ne(&dynamic::sym0("foo"), &dynamic::sym0("bar"));
        test_state.assert_full_ne(&dynamic::sym0("foo"), &dynamic::sym1("foo"));
    }

    #[test]
    fn test_ord() {
        assert_ne!(STATIC_A_0.cmp(&STATIC_A_1), Ordering::Equal);
        assert_ne!(STATIC_A_0.cmp(&STATIC_B_0), Ordering::Equal);
        assert_ne!(STATIC_A_1.cmp(&STATIC_B_0), Ordering::Equal);
    }
}
